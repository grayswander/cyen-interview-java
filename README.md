# Cyren Java interview task

## Goal
Given _Event_ type with the following data:
- *id* - unique event ID
- *type* - event type
- *timestamp* - event timestamp (simple Date is enough)
- *message* - event body

Implement the following aggregation:
- *type* - event type
- *periodStart* - First timestamp of aggregation period.
- *count* - event count by _type_ within _period_

Aggregation parameter:
- *period* - Aggregation period speification (represented by Simple Date Format)

Implement _EventAggregator_ interface with three event aggregation methods:
- One for unordered collection of events.
- Second for a stream of events, ordered by timestamp. You can be sure, that each subsequent event timestamp in the stream will be greater or equal to previous event timestamp.
- Third for a Flux (reactive stream) of events, ordered by timestamp. You can be sure, that each subsequent event timestamp in the stream will be greater or equal to previous event timestamp.

NOTE: It is better to implement part of the interface the best way you can, than to get stuck with unfamiliar concept.

NOTE: Output result order is not important.

## You are provided with the following assets:
### _Event_ and _Aggregation_ class skeletons
Input and output types, initially contain only data fields.

Feel free to add any methods, decoratons, annotations, etc.
Do not change members.

### _EventAggregator_ interface
Implement this.

### _EventAggregatorSupplier_ factory class
Implement _get()_ method to return your implementation of _EventAggregator_ interface.

### _Utility_ class
Contains static methods, which generate input and build expected output.

### _Application_ entry point with _main()_ method.
Just for your convenience, shows usage of _Utility_, _EventAggregator_ and _EventAggregatorSupplier_.

Example output of _main()_ method:
```
Input data
----------
Event(id=id8, type=type2, timestamp=Mon Jan 18 11:27:17 IST 2021, message=Message8)
Event(id=id3, type=type1, timestamp=Sun Jan 17 15:26:17 IST 2021, message=Message3)
Event(id=id1, type=type1, timestamp=Sun Jan 17 11:23:17 IST 2021, message=Message1)
Event(id=id4, type=type1, timestamp=Mon Jan 18 11:23:17 IST 2021, message=Message4)
Event(id=id5, type=type2, timestamp=Mon Jan 18 11:24:17 IST 2021, message=Message5)
Event(id=id0, type=type2, timestamp=Mon Jan 18 11:28:17 IST 2021, message=Message0)
Event(id=id6, type=type1, timestamp=Mon Jan 18 11:25:17 IST 2021, message=Message6)
Event(id=id2, type=type2, timestamp=Sun Jan 17 15:23:17 IST 2021, message=Message2)
Event(id=id9, type=type1, timestamp=Mon Jan 18 11:28:17 IST 2021, message=Message9)
Event(id=id7, type=type2, timestamp=Mon Jan 18 11:26:17 IST 2021, message=Message7)

Period spec: yyyy-MM-dd

Stream
----------
Aggregation(periodStart=Sun Jan 17 00:00:00 IST 2021, type=type2, count=1)
Aggregation(periodStart=Sun Jan 17 00:00:00 IST 2021, type=type1, count=2)
Aggregation(periodStart=Mon Jan 18 00:00:00 IST 2021, type=type2, count=4)
Aggregation(periodStart=Mon Jan 18 00:00:00 IST 2021, type=type1, count=3)

Collection
----------
Aggregation(periodStart=Sun Jan 17 00:00:00 IST 2021, type=type2, count=1)
Aggregation(periodStart=Sun Jan 17 00:00:00 IST 2021, type=type1, count=2)
Aggregation(periodStart=Mon Jan 18 00:00:00 IST 2021, type=type2, count=4)
Aggregation(periodStart=Mon Jan 18 00:00:00 IST 2021, type=type1, count=3)

Flux
----------
Aggregation(periodStart=Sun Jan 17 00:00:00 IST 2021, type=type2, count=1)
Aggregation(periodStart=Sun Jan 17 00:00:00 IST 2021, type=type1, count=2)
Aggregation(periodStart=Mon Jan 18 00:00:00 IST 2021, type=type2, count=4)
Aggregation(periodStart=Mon Jan 18 00:00:00 IST 2021, type=type1, count=3)
```

NOTE: Input stream, generated by _com.cyren.interview.Utility.buildOrderedInputStream_ is ordered by timestamp.
NOTE: Input Flux, generated by _com.cyren.interview.Utility.buildOrderedInputFlux_ is ordered by timestamp.

### _EventAggregatorTest_
Test for interface methods, you will implement.
Uses _Utility_ class to get input and expected output data.